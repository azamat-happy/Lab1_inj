# Lab1_inj
### Первая лабораторная работа по компьютерной графике.
### Выполнил: Шарипов Азамат
### Группа: МО-221
# Было сделано:
## Установка необходимых библиотек OpegGL (glm, freeglut, glew)
## Создание окна
    // Инициализация glut
    glutInit(&argc, argv);
    //двойная буферизация и буфер цвета
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA);
    //задание размера окна (ширина, высота)
    glutInitWindowSize(1024, 768);
    //задание положения позиции окна (x и y относительно левого верхнего угла)
    glutInitWindowPosition(100, 100);
    //создание окна приложения с названием "Tutorial 01"
    glutCreateWindow("Tutorial 01");
    
    //очищение окна (используя цвет, заданный выше)
    glClear(GL_COLOR_BUFFER_BIT);
    // Меняем фоновый буфер и буфер кадра местами
    glutSwapBuffers();
    
    //Этот вызов передаёт контроль GLUT'у, который теперь начнёт свой собственный цикл
    //В следующем вызове рендер будет происходить в текущий буфер кадра, а фоновый буфер будет отображается.
    // В этом цикле он ждёт событий от оконной системы и передаёт их через функции обратного вызова, которые мы задали ранее
    //В нашем случае GLUT будет вызывать только функцию отображения на экран, что бы дать ей возможность нарисовать кадр.
    glutMainLoop();

## Рисование точки
###### Объявление глобальной переменной
    GLuint VBO;
###### main:
    // Инициализируем glew
    GLenum res = glewInit();
    if (res != GLEW_OK)
    {
        fprintf(stderr, "Error: '%s'\n", glewGetErrorString(res));
        return 1;
    }
    //Создаем массив типа glm::vec3
    glm::vec3  Vertices[1];
    // Создаём вектор в центре экрана (x=0, y=0, z=0 - центр экрана)
    Vertices[0] = glm::vec3 (0.0f, 0.0f, 0.0f);
    
    // Генерируем объект(количество объектов, ссылка на массив для хранения)
    glGenBuffers(1, &VBO);
    //Указываем OpenGL, что в VBO будет храниться массив вершин (цель, указатель на массив)
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    //наполняем объект данными(название цели, размер данных в байтах, адрес массива вершин,
    //и флаг, который обозначает использование паттернов для этих данных
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
    
    // Разрешение использования каждого атрибута вершины (аттрибут вершины)
    glEnableVertexAttribArray(0);
    // Обратно привязываем буфер, приготавливая для отрисовки
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    //Этот вызов говорит конвейеру как воспринимать данные внутри буфера(индекс атрибута, количество аттрибутов,
    // тип данных каждого компонента, нормализировать ли данные перед использованием, шаг - число байтов
    // между двумя экземплярами атрибута, смещение первого компонента первого универсального атрибута вершины)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);
    //вызвали функцию для отрисовки (режим рисования, индекс первого элемента в буфере, количество элементов)
    glDrawArrays(GL_POINTS, 0, 1);
    // Отключение каждого атрибута вершины
    glDisableVertexAttribArray(0);
## Рисование треугольника
###### В коде "Рисование точки":
    //увеличиваем массив, чтобы он мог содержать три вершины
    //создаем массив типа glm::vec3
    glm::vec3 Vertices[3];
    //создаем объекты с координатами и помещаем их в соответсвующие ячейки массива
    Vertices[0] = glm::vec3(-1.0f, -1.0f, 0.0f);
    Vertices[1] = glm::vec3(1.0f, -1.0f, 0.0f);
    Vertices[2] = glm::vec3(0.0f, 1.0f, 0.0f);
    
    //принимаем 3 вершины вместо (режим рисования, индекс первого элемента в буфере, количество элементов)
    glDrawArrays(GL_TRIANGLES, 0, 3);
# Итог
Я научился создавать окно и рисовать простейшие объекты в OpenGL, а также писать отчеты в README!
